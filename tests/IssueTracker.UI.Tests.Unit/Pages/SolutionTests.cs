namespace IssueTracker.UI.Pages;[ExcludeFromCodeCoverage]public class SolutionTests : TestContext{	private readonly Mock<ICommentRepository> _commentRepositoryMock;	private readonly List<CommentModel> _expectedComments;	private readonly IssueModel _expectedIssue;	private readonly UserModel _expectedUser;	private readonly Mock<IIssueRepository> _issueRepositoryMock;	private readonly Mock<IMemoryCache> _memoryCacheMock;	private readonly Mock<ICacheEntry> _mockCacheEntry;	private readonly Mock<IUserRepository> _userRepositoryMock;	public SolutionTests()	{		_issueRepositoryMock = new Mock<IIssueRepository>();		_commentRepositoryMock = new Mock<ICommentRepository>();		_userRepositoryMock = new Mock<IUserRepository>();		_memoryCacheMock = new Mock<IMemoryCache>();		_mockCacheEntry = new Mock<ICacheEntry>();		_expectedUser = FakeUser.GetNewUser(true);		_expectedIssue = FakeIssue.GetNewIssue(true);		_expectedComments = FakeComment.GetComments(1).ToList();	}	private IRenderedComponent<Solution> ComponentUnderTest(string? issueId)	{		SetupMocks();		SetMemoryCache();		RegisterServices();		var component = RenderComponent<Solution>(parameter =>		{			parameter.Add(p => p.Id, issueId);		});		return component;	}	[Fact(DisplayName = "Solution Page Check Logged In User With Null User")]	public void Solution_With_NullLoggedInUser_Should_ThrowAArgumentNullException_TestAsync()	{		// Arrange		const string expectedParamName = "userObjectIdentifierId";		const string expectedMessage = "Value cannot be null.?*";		SetAuthenticationAndAuthorization(false, false);		// Act		var cut = () => ComponentUnderTest(_expectedIssue.Id);		// Assert		cut.Should()			.Throw<ArgumentNullException>()			.WithParameterName(expectedParamName)			.WithMessage(expectedMessage);	}	[Fact(DisplayName = "Solution Page Check Logged In User With Valid User")]	public void CheckLoggedInUser_With_ValidUser_Should_DisplayAUser_TestAsync()	{		// Arrange		SetAuthenticationAndAuthorization(false, true);		// Act		var cut = ComponentUnderTest(_expectedIssue.Id);		// Assert		cut.MarkupMatches		(			"""				<h3>Solution</h3>				<h1 class="page-heading text-light text-uppercase mb-4">Solution to an Issue</h1>				"""		);	}	[Fact]	public void Solution_CloseButton_Should_WhenClickedNavigateToIndexPage_Test()	{		// Arrange		const string expectedUri = "http://localhost/";		SetAuthenticationAndAuthorization(false, true);		// Act		var cut = ComponentUnderTest(_expectedIssue.Id);		cut.Find("#close-page").Click();		// Assert		var navMan = Services.GetRequiredService<FakeNavigationManager>();		navMan.Uri.Should().NotBeNull();		navMan.Uri.Should().Be(expectedUri);	}		private void SetupMocks()	{		_issueRepositoryMock			.Setup(x => x				.GetAsync(_expectedIssue.Id))			.ReturnsAsync(_expectedIssue);		_userRepositoryMock			.Setup(x => x				.GetFromAuthenticationAsync(It.IsAny<string>()))			.ReturnsAsync(_expectedUser);		_commentRepositoryMock			.Setup(x => x				.GetByUserAsync(It.IsAny<string>()))			.ReturnsAsync(_expectedComments);	}	private void SetAuthenticationAndAuthorization(bool isAdmin, bool isAuth)	{		var authContext = this.AddTestAuthorization();		if (isAuth)		{			authContext.SetAuthorized(_expectedUser.DisplayName);			authContext.SetClaims(				new Claim("objectidentifier", _expectedUser.Id)			);		}		if (isAdmin)		{			authContext.SetPolicies("Admin");		}	}	private void RegisterServices()	{		Services.AddSingleton<IIssueService>(			new IssueService(_issueRepositoryMock.Object, _memoryCacheMock.Object));		Services.AddSingleton<ICommentService>(			new CommentService(_commentRepositoryMock.Object, _memoryCacheMock.Object));		Services.AddSingleton<IUserService>(new UserService(_userRepositoryMock.Object));	}	private void SetMemoryCache()	{		_memoryCacheMock			.Setup(mc => mc.CreateEntry(It.IsAny<object>()))			.Callback((object k) => _ = (string)k)			.Returns(_mockCacheEntry.Object);	}}